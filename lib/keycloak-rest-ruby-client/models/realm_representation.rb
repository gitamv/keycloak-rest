=begin
#Keycloak Admin REST API

#This is a REST API reference for the Keycloak Admin

The version of the OpenAPI document: 1

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.0.0-SNAPSHOT

=end

require 'date'

module KeycloakRest
  class RealmRepresentation
    attr_accessor :access_code_lifespan

    attr_accessor :access_code_lifespan_login

    attr_accessor :access_code_lifespan_user_action

    attr_accessor :access_token_lifespan

    attr_accessor :access_token_lifespan_for_implicit_flow

    attr_accessor :account_theme

    attr_accessor :action_token_generated_by_admin_lifespan

    attr_accessor :action_token_generated_by_user_lifespan

    attr_accessor :admin_events_details_enabled

    attr_accessor :admin_events_enabled

    attr_accessor :admin_theme

    attr_accessor :attributes

    attr_accessor :authentication_flows

    attr_accessor :authenticator_config

    attr_accessor :browser_flow

    attr_accessor :browser_security_headers

    attr_accessor :brute_force_protected

    attr_accessor :client_authentication_flow

    attr_accessor :client_offline_session_idle_timeout

    attr_accessor :client_offline_session_max_lifespan

    attr_accessor :client_scope_mappings

    attr_accessor :client_scopes

    attr_accessor :client_session_idle_timeout

    attr_accessor :client_session_max_lifespan

    attr_accessor :clients

    attr_accessor :components

    attr_accessor :default_default_client_scopes

    attr_accessor :default_groups

    attr_accessor :default_locale

    attr_accessor :default_optional_client_scopes

    attr_accessor :default_roles

    attr_accessor :default_signature_algorithm

    attr_accessor :direct_grant_flow

    attr_accessor :display_name

    attr_accessor :display_name_html

    attr_accessor :docker_authentication_flow

    attr_accessor :duplicate_emails_allowed

    attr_accessor :edit_username_allowed

    attr_accessor :email_theme

    attr_accessor :enabled

    attr_accessor :enabled_event_types

    attr_accessor :events_enabled

    attr_accessor :events_expiration

    attr_accessor :events_listeners

    attr_accessor :failure_factor

    attr_accessor :federated_users

    attr_accessor :groups

    attr_accessor :id

    attr_accessor :identity_provider_mappers

    attr_accessor :identity_providers

    attr_accessor :internationalization_enabled

    attr_accessor :keycloak_version

    attr_accessor :login_theme

    attr_accessor :login_with_email_allowed

    attr_accessor :max_delta_time_seconds

    attr_accessor :max_failure_wait_seconds

    attr_accessor :minimum_quick_login_wait_seconds

    attr_accessor :not_before

    attr_accessor :offline_session_idle_timeout

    attr_accessor :offline_session_max_lifespan

    attr_accessor :offline_session_max_lifespan_enabled

    attr_accessor :otp_policy_algorithm

    attr_accessor :otp_policy_digits

    attr_accessor :otp_policy_initial_counter

    attr_accessor :otp_policy_look_ahead_window

    attr_accessor :otp_policy_period

    attr_accessor :otp_policy_type

    attr_accessor :otp_supported_applications

    attr_accessor :password_policy

    attr_accessor :permanent_lockout

    attr_accessor :protocol_mappers

    attr_accessor :quick_login_check_milli_seconds

    attr_accessor :realm

    attr_accessor :refresh_token_max_reuse

    attr_accessor :registration_allowed

    attr_accessor :registration_email_as_username

    attr_accessor :registration_flow

    attr_accessor :remember_me

    attr_accessor :required_actions

    attr_accessor :reset_credentials_flow

    attr_accessor :reset_password_allowed

    attr_accessor :revoke_refresh_token

    attr_accessor :roles

    attr_accessor :scope_mappings

    attr_accessor :smtp_server

    attr_accessor :ssl_required

    attr_accessor :sso_session_idle_timeout

    attr_accessor :sso_session_idle_timeout_remember_me

    attr_accessor :sso_session_max_lifespan

    attr_accessor :sso_session_max_lifespan_remember_me

    attr_accessor :supported_locales

    attr_accessor :user_federation_mappers

    attr_accessor :user_federation_providers

    attr_accessor :user_managed_access_allowed

    attr_accessor :users

    attr_accessor :verify_email

    attr_accessor :wait_increment_seconds

    attr_accessor :web_authn_policy_acceptable_aaguids

    attr_accessor :web_authn_policy_attestation_conveyance_preference

    attr_accessor :web_authn_policy_authenticator_attachment

    attr_accessor :web_authn_policy_avoid_same_authenticator_register

    attr_accessor :web_authn_policy_create_timeout

    attr_accessor :web_authn_policy_passwordless_acceptable_aaguids

    attr_accessor :web_authn_policy_passwordless_attestation_conveyance_preference

    attr_accessor :web_authn_policy_passwordless_authenticator_attachment

    attr_accessor :web_authn_policy_passwordless_avoid_same_authenticator_register

    attr_accessor :web_authn_policy_passwordless_create_timeout

    attr_accessor :web_authn_policy_passwordless_require_resident_key

    attr_accessor :web_authn_policy_passwordless_rp_entity_name

    attr_accessor :web_authn_policy_passwordless_rp_id

    attr_accessor :web_authn_policy_passwordless_signature_algorithms

    attr_accessor :web_authn_policy_passwordless_user_verification_requirement

    attr_accessor :web_authn_policy_require_resident_key

    attr_accessor :web_authn_policy_rp_entity_name

    attr_accessor :web_authn_policy_rp_id

    attr_accessor :web_authn_policy_signature_algorithms

    attr_accessor :web_authn_policy_user_verification_requirement

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'access_code_lifespan' => :'accessCodeLifespan',
        :'access_code_lifespan_login' => :'accessCodeLifespanLogin',
        :'access_code_lifespan_user_action' => :'accessCodeLifespanUserAction',
        :'access_token_lifespan' => :'accessTokenLifespan',
        :'access_token_lifespan_for_implicit_flow' => :'accessTokenLifespanForImplicitFlow',
        :'account_theme' => :'accountTheme',
        :'action_token_generated_by_admin_lifespan' => :'actionTokenGeneratedByAdminLifespan',
        :'action_token_generated_by_user_lifespan' => :'actionTokenGeneratedByUserLifespan',
        :'admin_events_details_enabled' => :'adminEventsDetailsEnabled',
        :'admin_events_enabled' => :'adminEventsEnabled',
        :'admin_theme' => :'adminTheme',
        :'attributes' => :'attributes',
        :'authentication_flows' => :'authenticationFlows',
        :'authenticator_config' => :'authenticatorConfig',
        :'browser_flow' => :'browserFlow',
        :'browser_security_headers' => :'browserSecurityHeaders',
        :'brute_force_protected' => :'bruteForceProtected',
        :'client_authentication_flow' => :'clientAuthenticationFlow',
        :'client_offline_session_idle_timeout' => :'clientOfflineSessionIdleTimeout',
        :'client_offline_session_max_lifespan' => :'clientOfflineSessionMaxLifespan',
        :'client_scope_mappings' => :'clientScopeMappings',
        :'client_scopes' => :'clientScopes',
        :'client_session_idle_timeout' => :'clientSessionIdleTimeout',
        :'client_session_max_lifespan' => :'clientSessionMaxLifespan',
        :'clients' => :'clients',
        :'components' => :'components',
        :'default_default_client_scopes' => :'defaultDefaultClientScopes',
        :'default_groups' => :'defaultGroups',
        :'default_locale' => :'defaultLocale',
        :'default_optional_client_scopes' => :'defaultOptionalClientScopes',
        :'default_roles' => :'defaultRoles',
        :'default_signature_algorithm' => :'defaultSignatureAlgorithm',
        :'direct_grant_flow' => :'directGrantFlow',
        :'display_name' => :'displayName',
        :'display_name_html' => :'displayNameHtml',
        :'docker_authentication_flow' => :'dockerAuthenticationFlow',
        :'duplicate_emails_allowed' => :'duplicateEmailsAllowed',
        :'edit_username_allowed' => :'editUsernameAllowed',
        :'email_theme' => :'emailTheme',
        :'enabled' => :'enabled',
        :'enabled_event_types' => :'enabledEventTypes',
        :'events_enabled' => :'eventsEnabled',
        :'events_expiration' => :'eventsExpiration',
        :'events_listeners' => :'eventsListeners',
        :'failure_factor' => :'failureFactor',
        :'federated_users' => :'federatedUsers',
        :'groups' => :'groups',
        :'id' => :'id',
        :'identity_provider_mappers' => :'identityProviderMappers',
        :'identity_providers' => :'identityProviders',
        :'internationalization_enabled' => :'internationalizationEnabled',
        :'keycloak_version' => :'keycloakVersion',
        :'login_theme' => :'loginTheme',
        :'login_with_email_allowed' => :'loginWithEmailAllowed',
        :'max_delta_time_seconds' => :'maxDeltaTimeSeconds',
        :'max_failure_wait_seconds' => :'maxFailureWaitSeconds',
        :'minimum_quick_login_wait_seconds' => :'minimumQuickLoginWaitSeconds',
        :'not_before' => :'notBefore',
        :'offline_session_idle_timeout' => :'offlineSessionIdleTimeout',
        :'offline_session_max_lifespan' => :'offlineSessionMaxLifespan',
        :'offline_session_max_lifespan_enabled' => :'offlineSessionMaxLifespanEnabled',
        :'otp_policy_algorithm' => :'otpPolicyAlgorithm',
        :'otp_policy_digits' => :'otpPolicyDigits',
        :'otp_policy_initial_counter' => :'otpPolicyInitialCounter',
        :'otp_policy_look_ahead_window' => :'otpPolicyLookAheadWindow',
        :'otp_policy_period' => :'otpPolicyPeriod',
        :'otp_policy_type' => :'otpPolicyType',
        :'otp_supported_applications' => :'otpSupportedApplications',
        :'password_policy' => :'passwordPolicy',
        :'permanent_lockout' => :'permanentLockout',
        :'protocol_mappers' => :'protocolMappers',
        :'quick_login_check_milli_seconds' => :'quickLoginCheckMilliSeconds',
        :'realm' => :'realm',
        :'refresh_token_max_reuse' => :'refreshTokenMaxReuse',
        :'registration_allowed' => :'registrationAllowed',
        :'registration_email_as_username' => :'registrationEmailAsUsername',
        :'registration_flow' => :'registrationFlow',
        :'remember_me' => :'rememberMe',
        :'required_actions' => :'requiredActions',
        :'reset_credentials_flow' => :'resetCredentialsFlow',
        :'reset_password_allowed' => :'resetPasswordAllowed',
        :'revoke_refresh_token' => :'revokeRefreshToken',
        :'roles' => :'roles',
        :'scope_mappings' => :'scopeMappings',
        :'smtp_server' => :'smtpServer',
        :'ssl_required' => :'sslRequired',
        :'sso_session_idle_timeout' => :'ssoSessionIdleTimeout',
        :'sso_session_idle_timeout_remember_me' => :'ssoSessionIdleTimeoutRememberMe',
        :'sso_session_max_lifespan' => :'ssoSessionMaxLifespan',
        :'sso_session_max_lifespan_remember_me' => :'ssoSessionMaxLifespanRememberMe',
        :'supported_locales' => :'supportedLocales',
        :'user_federation_mappers' => :'userFederationMappers',
        :'user_federation_providers' => :'userFederationProviders',
        :'user_managed_access_allowed' => :'userManagedAccessAllowed',
        :'users' => :'users',
        :'verify_email' => :'verifyEmail',
        :'wait_increment_seconds' => :'waitIncrementSeconds',
        :'web_authn_policy_acceptable_aaguids' => :'webAuthnPolicyAcceptableAaguids',
        :'web_authn_policy_attestation_conveyance_preference' => :'webAuthnPolicyAttestationConveyancePreference',
        :'web_authn_policy_authenticator_attachment' => :'webAuthnPolicyAuthenticatorAttachment',
        :'web_authn_policy_avoid_same_authenticator_register' => :'webAuthnPolicyAvoidSameAuthenticatorRegister',
        :'web_authn_policy_create_timeout' => :'webAuthnPolicyCreateTimeout',
        :'web_authn_policy_passwordless_acceptable_aaguids' => :'webAuthnPolicyPasswordlessAcceptableAaguids',
        :'web_authn_policy_passwordless_attestation_conveyance_preference' => :'webAuthnPolicyPasswordlessAttestationConveyancePreference',
        :'web_authn_policy_passwordless_authenticator_attachment' => :'webAuthnPolicyPasswordlessAuthenticatorAttachment',
        :'web_authn_policy_passwordless_avoid_same_authenticator_register' => :'webAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister',
        :'web_authn_policy_passwordless_create_timeout' => :'webAuthnPolicyPasswordlessCreateTimeout',
        :'web_authn_policy_passwordless_require_resident_key' => :'webAuthnPolicyPasswordlessRequireResidentKey',
        :'web_authn_policy_passwordless_rp_entity_name' => :'webAuthnPolicyPasswordlessRpEntityName',
        :'web_authn_policy_passwordless_rp_id' => :'webAuthnPolicyPasswordlessRpId',
        :'web_authn_policy_passwordless_signature_algorithms' => :'webAuthnPolicyPasswordlessSignatureAlgorithms',
        :'web_authn_policy_passwordless_user_verification_requirement' => :'webAuthnPolicyPasswordlessUserVerificationRequirement',
        :'web_authn_policy_require_resident_key' => :'webAuthnPolicyRequireResidentKey',
        :'web_authn_policy_rp_entity_name' => :'webAuthnPolicyRpEntityName',
        :'web_authn_policy_rp_id' => :'webAuthnPolicyRpId',
        :'web_authn_policy_signature_algorithms' => :'webAuthnPolicySignatureAlgorithms',
        :'web_authn_policy_user_verification_requirement' => :'webAuthnPolicyUserVerificationRequirement'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'access_code_lifespan' => :'Integer',
        :'access_code_lifespan_login' => :'Integer',
        :'access_code_lifespan_user_action' => :'Integer',
        :'access_token_lifespan' => :'Integer',
        :'access_token_lifespan_for_implicit_flow' => :'Integer',
        :'account_theme' => :'String',
        :'action_token_generated_by_admin_lifespan' => :'Integer',
        :'action_token_generated_by_user_lifespan' => :'Integer',
        :'admin_events_details_enabled' => :'Boolean',
        :'admin_events_enabled' => :'Boolean',
        :'admin_theme' => :'String',
        :'attributes' => :'Hash<String, Object>',
        :'authentication_flows' => :'Array<AuthenticationFlowRepresentation>',
        :'authenticator_config' => :'Array<AuthenticatorConfigRepresentation>',
        :'browser_flow' => :'String',
        :'browser_security_headers' => :'Hash<String, Object>',
        :'brute_force_protected' => :'Boolean',
        :'client_authentication_flow' => :'String',
        :'client_offline_session_idle_timeout' => :'Integer',
        :'client_offline_session_max_lifespan' => :'Integer',
        :'client_scope_mappings' => :'Hash<String, Object>',
        :'client_scopes' => :'Array<ClientScopeRepresentation>',
        :'client_session_idle_timeout' => :'Integer',
        :'client_session_max_lifespan' => :'Integer',
        :'clients' => :'Array<ClientRepresentation>',
        :'components' => :'MultivaluedHashMap',
        :'default_default_client_scopes' => :'Array<String>',
        :'default_groups' => :'Array<String>',
        :'default_locale' => :'String',
        :'default_optional_client_scopes' => :'Array<String>',
        :'default_roles' => :'Array<String>',
        :'default_signature_algorithm' => :'String',
        :'direct_grant_flow' => :'String',
        :'display_name' => :'String',
        :'display_name_html' => :'String',
        :'docker_authentication_flow' => :'String',
        :'duplicate_emails_allowed' => :'Boolean',
        :'edit_username_allowed' => :'Boolean',
        :'email_theme' => :'String',
        :'enabled' => :'Boolean',
        :'enabled_event_types' => :'Array<String>',
        :'events_enabled' => :'Boolean',
        :'events_expiration' => :'Integer',
        :'events_listeners' => :'Array<String>',
        :'failure_factor' => :'Integer',
        :'federated_users' => :'Array<UserRepresentation>',
        :'groups' => :'Array<GroupRepresentation>',
        :'id' => :'String',
        :'identity_provider_mappers' => :'Array<IdentityProviderMapperRepresentation>',
        :'identity_providers' => :'Array<IdentityProviderRepresentation>',
        :'internationalization_enabled' => :'Boolean',
        :'keycloak_version' => :'String',
        :'login_theme' => :'String',
        :'login_with_email_allowed' => :'Boolean',
        :'max_delta_time_seconds' => :'Integer',
        :'max_failure_wait_seconds' => :'Integer',
        :'minimum_quick_login_wait_seconds' => :'Integer',
        :'not_before' => :'Integer',
        :'offline_session_idle_timeout' => :'Integer',
        :'offline_session_max_lifespan' => :'Integer',
        :'offline_session_max_lifespan_enabled' => :'Boolean',
        :'otp_policy_algorithm' => :'String',
        :'otp_policy_digits' => :'Integer',
        :'otp_policy_initial_counter' => :'Integer',
        :'otp_policy_look_ahead_window' => :'Integer',
        :'otp_policy_period' => :'Integer',
        :'otp_policy_type' => :'String',
        :'otp_supported_applications' => :'Array<String>',
        :'password_policy' => :'String',
        :'permanent_lockout' => :'Boolean',
        :'protocol_mappers' => :'Array<ProtocolMapperRepresentation>',
        :'quick_login_check_milli_seconds' => :'Integer',
        :'realm' => :'String',
        :'refresh_token_max_reuse' => :'Integer',
        :'registration_allowed' => :'Boolean',
        :'registration_email_as_username' => :'Boolean',
        :'registration_flow' => :'String',
        :'remember_me' => :'Boolean',
        :'required_actions' => :'Array<RequiredActionProviderRepresentation>',
        :'reset_credentials_flow' => :'String',
        :'reset_password_allowed' => :'Boolean',
        :'revoke_refresh_token' => :'Boolean',
        :'roles' => :'RolesRepresentation',
        :'scope_mappings' => :'Array<ScopeMappingRepresentation>',
        :'smtp_server' => :'Hash<String, Object>',
        :'ssl_required' => :'String',
        :'sso_session_idle_timeout' => :'Integer',
        :'sso_session_idle_timeout_remember_me' => :'Integer',
        :'sso_session_max_lifespan' => :'Integer',
        :'sso_session_max_lifespan_remember_me' => :'Integer',
        :'supported_locales' => :'Array<String>',
        :'user_federation_mappers' => :'Array<UserFederationMapperRepresentation>',
        :'user_federation_providers' => :'Array<UserFederationProviderRepresentation>',
        :'user_managed_access_allowed' => :'Boolean',
        :'users' => :'Array<UserRepresentation>',
        :'verify_email' => :'Boolean',
        :'wait_increment_seconds' => :'Integer',
        :'web_authn_policy_acceptable_aaguids' => :'Array<String>',
        :'web_authn_policy_attestation_conveyance_preference' => :'String',
        :'web_authn_policy_authenticator_attachment' => :'String',
        :'web_authn_policy_avoid_same_authenticator_register' => :'Boolean',
        :'web_authn_policy_create_timeout' => :'Integer',
        :'web_authn_policy_passwordless_acceptable_aaguids' => :'Array<String>',
        :'web_authn_policy_passwordless_attestation_conveyance_preference' => :'String',
        :'web_authn_policy_passwordless_authenticator_attachment' => :'String',
        :'web_authn_policy_passwordless_avoid_same_authenticator_register' => :'Boolean',
        :'web_authn_policy_passwordless_create_timeout' => :'Integer',
        :'web_authn_policy_passwordless_require_resident_key' => :'String',
        :'web_authn_policy_passwordless_rp_entity_name' => :'String',
        :'web_authn_policy_passwordless_rp_id' => :'String',
        :'web_authn_policy_passwordless_signature_algorithms' => :'Array<String>',
        :'web_authn_policy_passwordless_user_verification_requirement' => :'String',
        :'web_authn_policy_require_resident_key' => :'String',
        :'web_authn_policy_rp_entity_name' => :'String',
        :'web_authn_policy_rp_id' => :'String',
        :'web_authn_policy_signature_algorithms' => :'Array<String>',
        :'web_authn_policy_user_verification_requirement' => :'String'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `KeycloakRest::RealmRepresentation` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `KeycloakRest::RealmRepresentation`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'access_code_lifespan')
        self.access_code_lifespan = attributes[:'access_code_lifespan']
      end

      if attributes.key?(:'access_code_lifespan_login')
        self.access_code_lifespan_login = attributes[:'access_code_lifespan_login']
      end

      if attributes.key?(:'access_code_lifespan_user_action')
        self.access_code_lifespan_user_action = attributes[:'access_code_lifespan_user_action']
      end

      if attributes.key?(:'access_token_lifespan')
        self.access_token_lifespan = attributes[:'access_token_lifespan']
      end

      if attributes.key?(:'access_token_lifespan_for_implicit_flow')
        self.access_token_lifespan_for_implicit_flow = attributes[:'access_token_lifespan_for_implicit_flow']
      end

      if attributes.key?(:'account_theme')
        self.account_theme = attributes[:'account_theme']
      end

      if attributes.key?(:'action_token_generated_by_admin_lifespan')
        self.action_token_generated_by_admin_lifespan = attributes[:'action_token_generated_by_admin_lifespan']
      end

      if attributes.key?(:'action_token_generated_by_user_lifespan')
        self.action_token_generated_by_user_lifespan = attributes[:'action_token_generated_by_user_lifespan']
      end

      if attributes.key?(:'admin_events_details_enabled')
        self.admin_events_details_enabled = attributes[:'admin_events_details_enabled']
      end

      if attributes.key?(:'admin_events_enabled')
        self.admin_events_enabled = attributes[:'admin_events_enabled']
      end

      if attributes.key?(:'admin_theme')
        self.admin_theme = attributes[:'admin_theme']
      end

      if attributes.key?(:'attributes')
        if (value = attributes[:'attributes']).is_a?(Hash)
          self.attributes = value
        end
      end

      if attributes.key?(:'authentication_flows')
        if (value = attributes[:'authentication_flows']).is_a?(Array)
          self.authentication_flows = value
        end
      end

      if attributes.key?(:'authenticator_config')
        if (value = attributes[:'authenticator_config']).is_a?(Array)
          self.authenticator_config = value
        end
      end

      if attributes.key?(:'browser_flow')
        self.browser_flow = attributes[:'browser_flow']
      end

      if attributes.key?(:'browser_security_headers')
        if (value = attributes[:'browser_security_headers']).is_a?(Hash)
          self.browser_security_headers = value
        end
      end

      if attributes.key?(:'brute_force_protected')
        self.brute_force_protected = attributes[:'brute_force_protected']
      end

      if attributes.key?(:'client_authentication_flow')
        self.client_authentication_flow = attributes[:'client_authentication_flow']
      end

      if attributes.key?(:'client_offline_session_idle_timeout')
        self.client_offline_session_idle_timeout = attributes[:'client_offline_session_idle_timeout']
      end

      if attributes.key?(:'client_offline_session_max_lifespan')
        self.client_offline_session_max_lifespan = attributes[:'client_offline_session_max_lifespan']
      end

      if attributes.key?(:'client_scope_mappings')
        if (value = attributes[:'client_scope_mappings']).is_a?(Hash)
          self.client_scope_mappings = value
        end
      end

      if attributes.key?(:'client_scopes')
        if (value = attributes[:'client_scopes']).is_a?(Array)
          self.client_scopes = value
        end
      end

      if attributes.key?(:'client_session_idle_timeout')
        self.client_session_idle_timeout = attributes[:'client_session_idle_timeout']
      end

      if attributes.key?(:'client_session_max_lifespan')
        self.client_session_max_lifespan = attributes[:'client_session_max_lifespan']
      end

      if attributes.key?(:'clients')
        if (value = attributes[:'clients']).is_a?(Array)
          self.clients = value
        end
      end

      if attributes.key?(:'components')
        self.components = attributes[:'components']
      end

      if attributes.key?(:'default_default_client_scopes')
        if (value = attributes[:'default_default_client_scopes']).is_a?(Array)
          self.default_default_client_scopes = value
        end
      end

      if attributes.key?(:'default_groups')
        if (value = attributes[:'default_groups']).is_a?(Array)
          self.default_groups = value
        end
      end

      if attributes.key?(:'default_locale')
        self.default_locale = attributes[:'default_locale']
      end

      if attributes.key?(:'default_optional_client_scopes')
        if (value = attributes[:'default_optional_client_scopes']).is_a?(Array)
          self.default_optional_client_scopes = value
        end
      end

      if attributes.key?(:'default_roles')
        if (value = attributes[:'default_roles']).is_a?(Array)
          self.default_roles = value
        end
      end

      if attributes.key?(:'default_signature_algorithm')
        self.default_signature_algorithm = attributes[:'default_signature_algorithm']
      end

      if attributes.key?(:'direct_grant_flow')
        self.direct_grant_flow = attributes[:'direct_grant_flow']
      end

      if attributes.key?(:'display_name')
        self.display_name = attributes[:'display_name']
      end

      if attributes.key?(:'display_name_html')
        self.display_name_html = attributes[:'display_name_html']
      end

      if attributes.key?(:'docker_authentication_flow')
        self.docker_authentication_flow = attributes[:'docker_authentication_flow']
      end

      if attributes.key?(:'duplicate_emails_allowed')
        self.duplicate_emails_allowed = attributes[:'duplicate_emails_allowed']
      end

      if attributes.key?(:'edit_username_allowed')
        self.edit_username_allowed = attributes[:'edit_username_allowed']
      end

      if attributes.key?(:'email_theme')
        self.email_theme = attributes[:'email_theme']
      end

      if attributes.key?(:'enabled')
        self.enabled = attributes[:'enabled']
      end

      if attributes.key?(:'enabled_event_types')
        if (value = attributes[:'enabled_event_types']).is_a?(Array)
          self.enabled_event_types = value
        end
      end

      if attributes.key?(:'events_enabled')
        self.events_enabled = attributes[:'events_enabled']
      end

      if attributes.key?(:'events_expiration')
        self.events_expiration = attributes[:'events_expiration']
      end

      if attributes.key?(:'events_listeners')
        if (value = attributes[:'events_listeners']).is_a?(Array)
          self.events_listeners = value
        end
      end

      if attributes.key?(:'failure_factor')
        self.failure_factor = attributes[:'failure_factor']
      end

      if attributes.key?(:'federated_users')
        if (value = attributes[:'federated_users']).is_a?(Array)
          self.federated_users = value
        end
      end

      if attributes.key?(:'groups')
        if (value = attributes[:'groups']).is_a?(Array)
          self.groups = value
        end
      end

      if attributes.key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.key?(:'identity_provider_mappers')
        if (value = attributes[:'identity_provider_mappers']).is_a?(Array)
          self.identity_provider_mappers = value
        end
      end

      if attributes.key?(:'identity_providers')
        if (value = attributes[:'identity_providers']).is_a?(Array)
          self.identity_providers = value
        end
      end

      if attributes.key?(:'internationalization_enabled')
        self.internationalization_enabled = attributes[:'internationalization_enabled']
      end

      if attributes.key?(:'keycloak_version')
        self.keycloak_version = attributes[:'keycloak_version']
      end

      if attributes.key?(:'login_theme')
        self.login_theme = attributes[:'login_theme']
      end

      if attributes.key?(:'login_with_email_allowed')
        self.login_with_email_allowed = attributes[:'login_with_email_allowed']
      end

      if attributes.key?(:'max_delta_time_seconds')
        self.max_delta_time_seconds = attributes[:'max_delta_time_seconds']
      end

      if attributes.key?(:'max_failure_wait_seconds')
        self.max_failure_wait_seconds = attributes[:'max_failure_wait_seconds']
      end

      if attributes.key?(:'minimum_quick_login_wait_seconds')
        self.minimum_quick_login_wait_seconds = attributes[:'minimum_quick_login_wait_seconds']
      end

      if attributes.key?(:'not_before')
        self.not_before = attributes[:'not_before']
      end

      if attributes.key?(:'offline_session_idle_timeout')
        self.offline_session_idle_timeout = attributes[:'offline_session_idle_timeout']
      end

      if attributes.key?(:'offline_session_max_lifespan')
        self.offline_session_max_lifespan = attributes[:'offline_session_max_lifespan']
      end

      if attributes.key?(:'offline_session_max_lifespan_enabled')
        self.offline_session_max_lifespan_enabled = attributes[:'offline_session_max_lifespan_enabled']
      end

      if attributes.key?(:'otp_policy_algorithm')
        self.otp_policy_algorithm = attributes[:'otp_policy_algorithm']
      end

      if attributes.key?(:'otp_policy_digits')
        self.otp_policy_digits = attributes[:'otp_policy_digits']
      end

      if attributes.key?(:'otp_policy_initial_counter')
        self.otp_policy_initial_counter = attributes[:'otp_policy_initial_counter']
      end

      if attributes.key?(:'otp_policy_look_ahead_window')
        self.otp_policy_look_ahead_window = attributes[:'otp_policy_look_ahead_window']
      end

      if attributes.key?(:'otp_policy_period')
        self.otp_policy_period = attributes[:'otp_policy_period']
      end

      if attributes.key?(:'otp_policy_type')
        self.otp_policy_type = attributes[:'otp_policy_type']
      end

      if attributes.key?(:'otp_supported_applications')
        if (value = attributes[:'otp_supported_applications']).is_a?(Array)
          self.otp_supported_applications = value
        end
      end

      if attributes.key?(:'password_policy')
        self.password_policy = attributes[:'password_policy']
      end

      if attributes.key?(:'permanent_lockout')
        self.permanent_lockout = attributes[:'permanent_lockout']
      end

      if attributes.key?(:'protocol_mappers')
        if (value = attributes[:'protocol_mappers']).is_a?(Array)
          self.protocol_mappers = value
        end
      end

      if attributes.key?(:'quick_login_check_milli_seconds')
        self.quick_login_check_milli_seconds = attributes[:'quick_login_check_milli_seconds']
      end

      if attributes.key?(:'realm')
        self.realm = attributes[:'realm']
      end

      if attributes.key?(:'refresh_token_max_reuse')
        self.refresh_token_max_reuse = attributes[:'refresh_token_max_reuse']
      end

      if attributes.key?(:'registration_allowed')
        self.registration_allowed = attributes[:'registration_allowed']
      end

      if attributes.key?(:'registration_email_as_username')
        self.registration_email_as_username = attributes[:'registration_email_as_username']
      end

      if attributes.key?(:'registration_flow')
        self.registration_flow = attributes[:'registration_flow']
      end

      if attributes.key?(:'remember_me')
        self.remember_me = attributes[:'remember_me']
      end

      if attributes.key?(:'required_actions')
        if (value = attributes[:'required_actions']).is_a?(Array)
          self.required_actions = value
        end
      end

      if attributes.key?(:'reset_credentials_flow')
        self.reset_credentials_flow = attributes[:'reset_credentials_flow']
      end

      if attributes.key?(:'reset_password_allowed')
        self.reset_password_allowed = attributes[:'reset_password_allowed']
      end

      if attributes.key?(:'revoke_refresh_token')
        self.revoke_refresh_token = attributes[:'revoke_refresh_token']
      end

      if attributes.key?(:'roles')
        self.roles = attributes[:'roles']
      end

      if attributes.key?(:'scope_mappings')
        if (value = attributes[:'scope_mappings']).is_a?(Array)
          self.scope_mappings = value
        end
      end

      if attributes.key?(:'smtp_server')
        if (value = attributes[:'smtp_server']).is_a?(Hash)
          self.smtp_server = value
        end
      end

      if attributes.key?(:'ssl_required')
        self.ssl_required = attributes[:'ssl_required']
      end

      if attributes.key?(:'sso_session_idle_timeout')
        self.sso_session_idle_timeout = attributes[:'sso_session_idle_timeout']
      end

      if attributes.key?(:'sso_session_idle_timeout_remember_me')
        self.sso_session_idle_timeout_remember_me = attributes[:'sso_session_idle_timeout_remember_me']
      end

      if attributes.key?(:'sso_session_max_lifespan')
        self.sso_session_max_lifespan = attributes[:'sso_session_max_lifespan']
      end

      if attributes.key?(:'sso_session_max_lifespan_remember_me')
        self.sso_session_max_lifespan_remember_me = attributes[:'sso_session_max_lifespan_remember_me']
      end

      if attributes.key?(:'supported_locales')
        if (value = attributes[:'supported_locales']).is_a?(Array)
          self.supported_locales = value
        end
      end

      if attributes.key?(:'user_federation_mappers')
        if (value = attributes[:'user_federation_mappers']).is_a?(Array)
          self.user_federation_mappers = value
        end
      end

      if attributes.key?(:'user_federation_providers')
        if (value = attributes[:'user_federation_providers']).is_a?(Array)
          self.user_federation_providers = value
        end
      end

      if attributes.key?(:'user_managed_access_allowed')
        self.user_managed_access_allowed = attributes[:'user_managed_access_allowed']
      end

      if attributes.key?(:'users')
        if (value = attributes[:'users']).is_a?(Array)
          self.users = value
        end
      end

      if attributes.key?(:'verify_email')
        self.verify_email = attributes[:'verify_email']
      end

      if attributes.key?(:'wait_increment_seconds')
        self.wait_increment_seconds = attributes[:'wait_increment_seconds']
      end

      if attributes.key?(:'web_authn_policy_acceptable_aaguids')
        if (value = attributes[:'web_authn_policy_acceptable_aaguids']).is_a?(Array)
          self.web_authn_policy_acceptable_aaguids = value
        end
      end

      if attributes.key?(:'web_authn_policy_attestation_conveyance_preference')
        self.web_authn_policy_attestation_conveyance_preference = attributes[:'web_authn_policy_attestation_conveyance_preference']
      end

      if attributes.key?(:'web_authn_policy_authenticator_attachment')
        self.web_authn_policy_authenticator_attachment = attributes[:'web_authn_policy_authenticator_attachment']
      end

      if attributes.key?(:'web_authn_policy_avoid_same_authenticator_register')
        self.web_authn_policy_avoid_same_authenticator_register = attributes[:'web_authn_policy_avoid_same_authenticator_register']
      end

      if attributes.key?(:'web_authn_policy_create_timeout')
        self.web_authn_policy_create_timeout = attributes[:'web_authn_policy_create_timeout']
      end

      if attributes.key?(:'web_authn_policy_passwordless_acceptable_aaguids')
        if (value = attributes[:'web_authn_policy_passwordless_acceptable_aaguids']).is_a?(Array)
          self.web_authn_policy_passwordless_acceptable_aaguids = value
        end
      end

      if attributes.key?(:'web_authn_policy_passwordless_attestation_conveyance_preference')
        self.web_authn_policy_passwordless_attestation_conveyance_preference = attributes[:'web_authn_policy_passwordless_attestation_conveyance_preference']
      end

      if attributes.key?(:'web_authn_policy_passwordless_authenticator_attachment')
        self.web_authn_policy_passwordless_authenticator_attachment = attributes[:'web_authn_policy_passwordless_authenticator_attachment']
      end

      if attributes.key?(:'web_authn_policy_passwordless_avoid_same_authenticator_register')
        self.web_authn_policy_passwordless_avoid_same_authenticator_register = attributes[:'web_authn_policy_passwordless_avoid_same_authenticator_register']
      end

      if attributes.key?(:'web_authn_policy_passwordless_create_timeout')
        self.web_authn_policy_passwordless_create_timeout = attributes[:'web_authn_policy_passwordless_create_timeout']
      end

      if attributes.key?(:'web_authn_policy_passwordless_require_resident_key')
        self.web_authn_policy_passwordless_require_resident_key = attributes[:'web_authn_policy_passwordless_require_resident_key']
      end

      if attributes.key?(:'web_authn_policy_passwordless_rp_entity_name')
        self.web_authn_policy_passwordless_rp_entity_name = attributes[:'web_authn_policy_passwordless_rp_entity_name']
      end

      if attributes.key?(:'web_authn_policy_passwordless_rp_id')
        self.web_authn_policy_passwordless_rp_id = attributes[:'web_authn_policy_passwordless_rp_id']
      end

      if attributes.key?(:'web_authn_policy_passwordless_signature_algorithms')
        if (value = attributes[:'web_authn_policy_passwordless_signature_algorithms']).is_a?(Array)
          self.web_authn_policy_passwordless_signature_algorithms = value
        end
      end

      if attributes.key?(:'web_authn_policy_passwordless_user_verification_requirement')
        self.web_authn_policy_passwordless_user_verification_requirement = attributes[:'web_authn_policy_passwordless_user_verification_requirement']
      end

      if attributes.key?(:'web_authn_policy_require_resident_key')
        self.web_authn_policy_require_resident_key = attributes[:'web_authn_policy_require_resident_key']
      end

      if attributes.key?(:'web_authn_policy_rp_entity_name')
        self.web_authn_policy_rp_entity_name = attributes[:'web_authn_policy_rp_entity_name']
      end

      if attributes.key?(:'web_authn_policy_rp_id')
        self.web_authn_policy_rp_id = attributes[:'web_authn_policy_rp_id']
      end

      if attributes.key?(:'web_authn_policy_signature_algorithms')
        if (value = attributes[:'web_authn_policy_signature_algorithms']).is_a?(Array)
          self.web_authn_policy_signature_algorithms = value
        end
      end

      if attributes.key?(:'web_authn_policy_user_verification_requirement')
        self.web_authn_policy_user_verification_requirement = attributes[:'web_authn_policy_user_verification_requirement']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          access_code_lifespan == o.access_code_lifespan &&
          access_code_lifespan_login == o.access_code_lifespan_login &&
          access_code_lifespan_user_action == o.access_code_lifespan_user_action &&
          access_token_lifespan == o.access_token_lifespan &&
          access_token_lifespan_for_implicit_flow == o.access_token_lifespan_for_implicit_flow &&
          account_theme == o.account_theme &&
          action_token_generated_by_admin_lifespan == o.action_token_generated_by_admin_lifespan &&
          action_token_generated_by_user_lifespan == o.action_token_generated_by_user_lifespan &&
          admin_events_details_enabled == o.admin_events_details_enabled &&
          admin_events_enabled == o.admin_events_enabled &&
          admin_theme == o.admin_theme &&
          attributes == o.attributes &&
          authentication_flows == o.authentication_flows &&
          authenticator_config == o.authenticator_config &&
          browser_flow == o.browser_flow &&
          browser_security_headers == o.browser_security_headers &&
          brute_force_protected == o.brute_force_protected &&
          client_authentication_flow == o.client_authentication_flow &&
          client_offline_session_idle_timeout == o.client_offline_session_idle_timeout &&
          client_offline_session_max_lifespan == o.client_offline_session_max_lifespan &&
          client_scope_mappings == o.client_scope_mappings &&
          client_scopes == o.client_scopes &&
          client_session_idle_timeout == o.client_session_idle_timeout &&
          client_session_max_lifespan == o.client_session_max_lifespan &&
          clients == o.clients &&
          components == o.components &&
          default_default_client_scopes == o.default_default_client_scopes &&
          default_groups == o.default_groups &&
          default_locale == o.default_locale &&
          default_optional_client_scopes == o.default_optional_client_scopes &&
          default_roles == o.default_roles &&
          default_signature_algorithm == o.default_signature_algorithm &&
          direct_grant_flow == o.direct_grant_flow &&
          display_name == o.display_name &&
          display_name_html == o.display_name_html &&
          docker_authentication_flow == o.docker_authentication_flow &&
          duplicate_emails_allowed == o.duplicate_emails_allowed &&
          edit_username_allowed == o.edit_username_allowed &&
          email_theme == o.email_theme &&
          enabled == o.enabled &&
          enabled_event_types == o.enabled_event_types &&
          events_enabled == o.events_enabled &&
          events_expiration == o.events_expiration &&
          events_listeners == o.events_listeners &&
          failure_factor == o.failure_factor &&
          federated_users == o.federated_users &&
          groups == o.groups &&
          id == o.id &&
          identity_provider_mappers == o.identity_provider_mappers &&
          identity_providers == o.identity_providers &&
          internationalization_enabled == o.internationalization_enabled &&
          keycloak_version == o.keycloak_version &&
          login_theme == o.login_theme &&
          login_with_email_allowed == o.login_with_email_allowed &&
          max_delta_time_seconds == o.max_delta_time_seconds &&
          max_failure_wait_seconds == o.max_failure_wait_seconds &&
          minimum_quick_login_wait_seconds == o.minimum_quick_login_wait_seconds &&
          not_before == o.not_before &&
          offline_session_idle_timeout == o.offline_session_idle_timeout &&
          offline_session_max_lifespan == o.offline_session_max_lifespan &&
          offline_session_max_lifespan_enabled == o.offline_session_max_lifespan_enabled &&
          otp_policy_algorithm == o.otp_policy_algorithm &&
          otp_policy_digits == o.otp_policy_digits &&
          otp_policy_initial_counter == o.otp_policy_initial_counter &&
          otp_policy_look_ahead_window == o.otp_policy_look_ahead_window &&
          otp_policy_period == o.otp_policy_period &&
          otp_policy_type == o.otp_policy_type &&
          otp_supported_applications == o.otp_supported_applications &&
          password_policy == o.password_policy &&
          permanent_lockout == o.permanent_lockout &&
          protocol_mappers == o.protocol_mappers &&
          quick_login_check_milli_seconds == o.quick_login_check_milli_seconds &&
          realm == o.realm &&
          refresh_token_max_reuse == o.refresh_token_max_reuse &&
          registration_allowed == o.registration_allowed &&
          registration_email_as_username == o.registration_email_as_username &&
          registration_flow == o.registration_flow &&
          remember_me == o.remember_me &&
          required_actions == o.required_actions &&
          reset_credentials_flow == o.reset_credentials_flow &&
          reset_password_allowed == o.reset_password_allowed &&
          revoke_refresh_token == o.revoke_refresh_token &&
          roles == o.roles &&
          scope_mappings == o.scope_mappings &&
          smtp_server == o.smtp_server &&
          ssl_required == o.ssl_required &&
          sso_session_idle_timeout == o.sso_session_idle_timeout &&
          sso_session_idle_timeout_remember_me == o.sso_session_idle_timeout_remember_me &&
          sso_session_max_lifespan == o.sso_session_max_lifespan &&
          sso_session_max_lifespan_remember_me == o.sso_session_max_lifespan_remember_me &&
          supported_locales == o.supported_locales &&
          user_federation_mappers == o.user_federation_mappers &&
          user_federation_providers == o.user_federation_providers &&
          user_managed_access_allowed == o.user_managed_access_allowed &&
          users == o.users &&
          verify_email == o.verify_email &&
          wait_increment_seconds == o.wait_increment_seconds &&
          web_authn_policy_acceptable_aaguids == o.web_authn_policy_acceptable_aaguids &&
          web_authn_policy_attestation_conveyance_preference == o.web_authn_policy_attestation_conveyance_preference &&
          web_authn_policy_authenticator_attachment == o.web_authn_policy_authenticator_attachment &&
          web_authn_policy_avoid_same_authenticator_register == o.web_authn_policy_avoid_same_authenticator_register &&
          web_authn_policy_create_timeout == o.web_authn_policy_create_timeout &&
          web_authn_policy_passwordless_acceptable_aaguids == o.web_authn_policy_passwordless_acceptable_aaguids &&
          web_authn_policy_passwordless_attestation_conveyance_preference == o.web_authn_policy_passwordless_attestation_conveyance_preference &&
          web_authn_policy_passwordless_authenticator_attachment == o.web_authn_policy_passwordless_authenticator_attachment &&
          web_authn_policy_passwordless_avoid_same_authenticator_register == o.web_authn_policy_passwordless_avoid_same_authenticator_register &&
          web_authn_policy_passwordless_create_timeout == o.web_authn_policy_passwordless_create_timeout &&
          web_authn_policy_passwordless_require_resident_key == o.web_authn_policy_passwordless_require_resident_key &&
          web_authn_policy_passwordless_rp_entity_name == o.web_authn_policy_passwordless_rp_entity_name &&
          web_authn_policy_passwordless_rp_id == o.web_authn_policy_passwordless_rp_id &&
          web_authn_policy_passwordless_signature_algorithms == o.web_authn_policy_passwordless_signature_algorithms &&
          web_authn_policy_passwordless_user_verification_requirement == o.web_authn_policy_passwordless_user_verification_requirement &&
          web_authn_policy_require_resident_key == o.web_authn_policy_require_resident_key &&
          web_authn_policy_rp_entity_name == o.web_authn_policy_rp_entity_name &&
          web_authn_policy_rp_id == o.web_authn_policy_rp_id &&
          web_authn_policy_signature_algorithms == o.web_authn_policy_signature_algorithms &&
          web_authn_policy_user_verification_requirement == o.web_authn_policy_user_verification_requirement
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [access_code_lifespan, access_code_lifespan_login, access_code_lifespan_user_action, access_token_lifespan, access_token_lifespan_for_implicit_flow, account_theme, action_token_generated_by_admin_lifespan, action_token_generated_by_user_lifespan, admin_events_details_enabled, admin_events_enabled, admin_theme, attributes, authentication_flows, authenticator_config, browser_flow, browser_security_headers, brute_force_protected, client_authentication_flow, client_offline_session_idle_timeout, client_offline_session_max_lifespan, client_scope_mappings, client_scopes, client_session_idle_timeout, client_session_max_lifespan, clients, components, default_default_client_scopes, default_groups, default_locale, default_optional_client_scopes, default_roles, default_signature_algorithm, direct_grant_flow, display_name, display_name_html, docker_authentication_flow, duplicate_emails_allowed, edit_username_allowed, email_theme, enabled, enabled_event_types, events_enabled, events_expiration, events_listeners, failure_factor, federated_users, groups, id, identity_provider_mappers, identity_providers, internationalization_enabled, keycloak_version, login_theme, login_with_email_allowed, max_delta_time_seconds, max_failure_wait_seconds, minimum_quick_login_wait_seconds, not_before, offline_session_idle_timeout, offline_session_max_lifespan, offline_session_max_lifespan_enabled, otp_policy_algorithm, otp_policy_digits, otp_policy_initial_counter, otp_policy_look_ahead_window, otp_policy_period, otp_policy_type, otp_supported_applications, password_policy, permanent_lockout, protocol_mappers, quick_login_check_milli_seconds, realm, refresh_token_max_reuse, registration_allowed, registration_email_as_username, registration_flow, remember_me, required_actions, reset_credentials_flow, reset_password_allowed, revoke_refresh_token, roles, scope_mappings, smtp_server, ssl_required, sso_session_idle_timeout, sso_session_idle_timeout_remember_me, sso_session_max_lifespan, sso_session_max_lifespan_remember_me, supported_locales, user_federation_mappers, user_federation_providers, user_managed_access_allowed, users, verify_email, wait_increment_seconds, web_authn_policy_acceptable_aaguids, web_authn_policy_attestation_conveyance_preference, web_authn_policy_authenticator_attachment, web_authn_policy_avoid_same_authenticator_register, web_authn_policy_create_timeout, web_authn_policy_passwordless_acceptable_aaguids, web_authn_policy_passwordless_attestation_conveyance_preference, web_authn_policy_passwordless_authenticator_attachment, web_authn_policy_passwordless_avoid_same_authenticator_register, web_authn_policy_passwordless_create_timeout, web_authn_policy_passwordless_require_resident_key, web_authn_policy_passwordless_rp_entity_name, web_authn_policy_passwordless_rp_id, web_authn_policy_passwordless_signature_algorithms, web_authn_policy_passwordless_user_verification_requirement, web_authn_policy_require_resident_key, web_authn_policy_rp_entity_name, web_authn_policy_rp_id, web_authn_policy_signature_algorithms, web_authn_policy_user_verification_requirement].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        KeycloakRest.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end
        
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
